from collections import namedtuple
import numpy as np
import py3nj
import time
import sys

import jax
import jax.tree_util as tu
from jax import random, vmap
import jax.numpy as jnp

# new package in jax.numpy
from qdpy_jax import gnool_jit as gjit
from qdpy_jax import build_cenmult_and_nbs as build_CENMULT_AND_NBS 
from qdpy_jax import build_supermatrix as build_supmat
from qdpy_jax import globalvars as gvar_jax
from qdpy_jax import load_multiplets
from qdpy_jax import jax_functions as jf
from qdpy_jax import wigner_map2 as wigmap
from qdpy_jax import prune_multiplets
from qdpy_jax.flax_jit import StaticArray

# importing pyro related packages
import numpyro
from numpyro.diagnostics import hpdi
import numpyro.distributions as dist
from numpyro.infer import NUTS, MCMC
from numpyro import handlers

jax.config.update('jax_platform_name', 'cpu')
numpyro.set_platform('cpu')

from jax.config import config
config.update('jax_enable_x64', True)


W1T = 1.
W3T = 1.
W5T = 1.


def model():
    # setting min and max value to be 0.1*true and 3.*true
    w1min, w1max = .1*abs(W1T), 3.*abs(W1T)
    w3min, w3max = .1*abs(W3T), 3.*abs(W3T)
    w5min, w5max = .1*abs(W5T), 3.*abs(W5T)
    
    w1 = numpyro.sample('w1', dist.Uniform(w1min, w1max))
    w3 = numpyro.sample('w3', dist.Uniform(w3min, w3max))
    w5 = numpyro.sample('w5', dist.Uniform(w5min, w5max))
    
    sigma = numpyro.sample('sigma', dist.Uniform(0.1, 10.0))


    eig_sample = jnp.array([])
    for i in range(nmults):
        n0st = StaticArray(GVARS.n0_arr[i])
        ell0st = StaticArray(GVARS.ell0_arr[i])
        CENMULT_AND_NBS = get_nt_cnbs(n0st, ell0st, GVARS_ST)
        # CENMULT_AND_NBS = tu.tree_map(lambda x: np.array(x), CENMULT_AND_NBS)
        SUBMAT_DICT = build_submat_ind(CENMULT_AND_NBS)
        print(SUBMAT_DICT.startx)
        # SUBMAT_DICT = tu.tree_map(lambda x: np.array(x), SUBMAT_DICT)
        fac = 1.0
        fac *= (1 + w1*1e-3)
        fac *= (1 + w3*1e-3)
        fac *= (1 + w5*1e-3)
        fac /= 2.0*CENMULT_AND_NBS.omega_nbs.value[0]
    return numpyro.sample('obs', dist.Normal(eig_sample, sigma), obs=1234.)

def get_eigs(mat):
    eigvals, eigvecs = jnp.linalg.eigh(mat)
    return eigvals


GVARS = gvar_jax.GlobalVars()
GVARS_PATHS, GVARS_TR, GVARS_ST = GVARS.get_all_GVAR()

# jitting various functions
get_nt_cnbs = build_CENMULT_AND_NBS.get_namedtuple_for_cenmult_and_neighbours
get_nt_cnbs_ = jax.jit(get_nt_cnbs)
build_submat_ind = build_supmat.build_SUBMAT_INDICES
build_submat_ind_ = jax.jit(build_supmat.build_SUBMAT_INDICES)

build_supermatrix = build_supmat.build_supermatrix_functions().get_func2build_supermatrix()
build_supermatrix_ = jax.jit(build_supermatrix)

# COMPILING JAX
# looping over the ells
t1c = time.time()

# extracting the pruned parameters for multiplets of interest
nl_pruned, nl_idx_pruned, omega_pruned, wig_list, wig_idx = \
    prune_multiplets.get_pruned_attributes(GVARS, GVARS_ST)

lm = load_multiplets.load_multiplets(GVARS, nl_pruned,
                                     nl_idx_pruned,
                                     omega_pruned)

GVARS_PRUNED_TR = jf.create_namedtuple('GVARS_TR',
                                       ['r',
                                        'rth',
                                        'rmin_ind',
                                        'rmax_ind',
                                        'fac_up',
                                        'fac_lo',
                                        'wsr',
                                        'U_arr',
                                        'V_arr',
                                        'wig_list'],
                                       (GVARS_TR.r,
                                        GVARS_TR.rth,
                                        GVARS_TR.rmin_ind,
                                        GVARS_TR.rmax_ind,
                                        GVARS_TR.fac_up,
                                        GVARS_TR.fac_lo,
                                        GVARS_TR.wsr,
                                        lm.U_arr,
                                        lm.V_arr,
                                        wig_list))

GVARS_PRUNED_ST = jf.create_namedtuple('GVARS_ST',
                                       ['s_arr',
                                        'nl_all',
                                        'nl_idx_pruned',
                                        'omega_list',
                                        'fwindow',
                                        'OM',
                                        'wig_idx'],
                                       (GVARS_ST.s_arr,
                                        lm.nl_pruned,
                                        lm.nl_idx_pruned,
                                        lm.omega_pruned,
                                        GVARS_ST.fwindow,
                                        GVARS_ST.OM,
                                        wig_idx),
                                       static=True)

nmults = len(GVARS.n0_arr)

for i in range(nmults):
    n0st = StaticArray(GVARS.n0_arr[i])
    ell0st = StaticArray(GVARS.ell0_arr[i])
    CENMULT_AND_NBS = get_nt_cnbs_(n0st, ell0st, GVARS_ST)
    CENMULT_AND_NBS = tu.tree_map(lambda x: np.array(x), CENMULT_AND_NBS)
    # SUBMAT_DICT = build_submat_ind_(CENMULT_AND_NBS)
    startx, starty, endx, endy = build_submat_ind_(CENMULT_AND_NBS)
    SUBMAT_DICT = jf.create_namedtuple('SUBMAT_DICT',
                                       ['startx',
                                        'starty',
                                        'endx',
                                        'endy'],
                                       (startx,
                                        starty,
                                        endx,
                                        endy),
                                       static=True)
    print(SUBMAT_DICT)
    #sys.exit()
    SUBMAT_DICT = tu.tree_map(lambda x: np.array(x), SUBMAT_DICT)
    '''
    supmatrix = build_supermatrix_(CENMULT_AND_NBS,
                                   SUBMAT_DICT,
                                   GVARS_PRUNED_ST,
                                   GVARS_PRUNED_TR).block_until_ready()
    '''
    print(f'Calculated supermatrix for multiplet = ({n0st}, {ell0st})')

# Start from this source of randomness. We will split keys for subsequent operations.
# rng_key = random.PRNGKey(12)
# rng_key, rng_key_ = random.split(rng_key)

# # Run NUTS.
# kernel = NUTS(model)
# mcmc = MCMC(kernel, num_warmup=50, num_samples=100)#, num_chains=5)
# sys.exit()

for i in range(nmults):
    class MetropolisHastings(numpyro.infer.mcmc.MCMCKernel):
...     sample_field = "u"
...
...     def __init__(self, potential_fn, step_size=0.1):
...         self.potential_fn = potential_fn
...         self.step_size = step_size
...
...     def init(self, rng_key, num_warmup, init_params, model_args, model_kwargs):
...         return MHState(init_params, rng_key)
...
...     def sample(self, state, model_args, model_kwargs):
...         u, rng_key = state
...         rng_key, key_proposal, key_accept = random.split(rng_key, 3)
...         u_proposal = dist.Normal(u, self.step_size).sample(key_proposal)
...         accept_prob = jnp.exp(self.potential_fn(u) - self.potential_fn(u_proposal))
...         u_new = 
    SUBMAT_DICT = build_SUBMAT_INDICES_(CENMULT_AND_NBS)
    SUBMAT_DICT = tu.tree_map(lambda x: np.array(x), SUBMAT_DICT)

    supmatrix = build_supermatrix_(CENMULT_AND_NBS,
                                   SUBMAT_DICT,
                                   GVARS_PRUNED_ST,
                                   GVARS_PRUNED_TR).block_until_ready()
    print(f'Calculated supermatrix for multiplet = ({n0}, {ell0})')
t2c = time.time()
print(f'Time taken in seconds for compilation of {nmults} multiplets' +
      f' =  {t2c-t1c:.2f} seconds')

# EXECUTING JAX
t1e = time.time()
print("--------------------------------------------------")
eigvals_true = np.array([])

for i in range(nmults):
    n0, ell0 = GVARS.n0_arr[i], GVARS.ell0_arr[i]

    # building the namedtuple for the central multiplet and its neighbours
    CENMULT_AND_NBS = get_namedtuple_for_cenmult_and_neighbours_(n0, ell0, GVARS_ST)
    CENMULT_AND_NBS = tu.tree_map(lambda x: np.array(x), CENMULT_AND_NBS)
    SUBMAT_DICT = build_SUBMAT_INDICES_(CENMULT_AND_NBS)
    SUBMAT_DICT = tu.tree_map(lambda x: np.array(x), SUBMAT_DICT)

    supmatrix = build_supermatrix_(CENMULT_AND_NBS, SUBMAT_DICT,
                                   GVARS_PRUNED_ST, GVARS_PRUNED_TR).block_until_ready()
    print(f'Calculated supermatrix for multiplet = ({n0}, {ell0})')
    eigvals_true = jnp.append(eigvals_true, np.diag(supmatrix))
t2e = time.time()

factor4niter = 1500 * 200./3600.
t_projected_jit = (t2e-t1e) / nmults * factor4niter
t_projected_eigval = 2. * factor4niter
print(f'Time taken in seconds by jax-jitted execution' +
      f' of entire simulation (1500 iterations) = {t_projected_jit:.2f} hours')

print(f'Assuming 2 seconds per eigenvalue problem solving, the ' +
      f'total time taken for EV solver (1500 iterations) = {t_projected_eigval:.2f} hours')

print('------------------')
print(f'Total time taken (1500 iterations) = ' +
      f'{(t_projected_jit + t_projected_eigval)/24.:.2f} days')

print(f'Fraction of time taken for setting up EV = ' +
      f'{t_projected_jit/t_projected_eigval:.3f}')

# Start from this source of randomness. We will split keys for subsequent operations.
rng_key = random.PRNGKey(12)
rng_key, rng_key_ = random.split(rng_key)

class MetropolisHastings(numpyro.infer.mcmc.MCMCKernel):
    sample_field = "u"

    def __init__(self, potential_fn, step_size=0.1):
        self.potential_fn = potential_fn
        self.step_size = step_size

    def init(self, rng_key, num_warmup, init_params, model_args, model_kwargs):
        return MHState(init_params, rng_key)

    def sample(self, state, model_args, model_kwargs):
        u, rng_key = state
        rng_key, key_proposal, key_accept = random.split(rng_key, 3)
        u_proposal = dist.Normal(u, self.step_size).sample(key_proposal)
        accept_prob = jnp.exp(self.potential_fn(u) - self.potential_fn(u_proposal))
        u_new = jnp.where(dist.Uniform().sample(key_accept) < accept_prob, u_proposal, u)
        return MHState(u_new, rng_key)

# Run NUTS.
# kernel = NUTS(model)
kernel = MetropolisHastings(model)
mcmc = MCMC(kernel, num_warmup=50, num_samples=100)#, num_chains=5)
